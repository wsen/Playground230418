{\rtf1\ansi\ansicpg1252\deff0{\fonttbl{\f0\fswiss\fcharset0 Helvetica;}{\f1\fnil\fcharset0 SabonLTStd-Roman;}{\f2\fnil\fcharset0 SourceCodePro-Regular;}}
{\colortbl ;\red255\green0\blue0;\red204\green204\blue204;}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\lang7\f0\fs24\par
EXCEPTIONS\par
? wer l\'f6st stack trace einer Exception aus?\par
? wann wird stack trace ausgel\'f6st?\par
Ausgabe: 3 Ways to print an exception\par
- \b\fs18 System.out.println(e)\b0 ;   \fs24 Java prints it out\par
- \b System.out.println(exception)\b0 , a stack trace is not printed. Just the name of the exception class and the message\par
- \b exception.printStackTrace(), \b0 a complete chain of the names of the methods called, along with the line numbers, is printed\par
\par
3 Ways to print an exception\par
- Java prints it out\tab\tab\fs18 System.out.println(e);\fs24\par
- Print just the message\tab\fs18 System.out.println(e.getMessage());\fs24\par
- Print where the stack trace comes from\tab\fs18 e.printStackTrace();\par
\par
\fs24 - The main method of a program can declare that it throws checked exceptions\par
- A method declaring that it throws a certain exception class may throw instances of any subclass of that exception class.\par
- The\cf1  overriding method \cf0 may opt not to declare any throws clause even if the original method has a throws clause.  An overriding method therefore cannot return a different type (except a subtype) or throw a wider spectrum of exceptions than the original method in the superclass. This, of course, applies only to checked exceptions because unchecked exceptions are not required to be declared at all.\par
\par
STANDARD JAVA EXCEPTION CLASSES\par
- java.io.FileNotFoundException\par
- java.lang.SecurityException RT\par
\par
POLYMORPHISM\line - A subclass may have a static method with the same signature as a static method in the base class but it is not called overriding. It is called\b  hiding \b0 because \b the concept of polymorphism doesn't apply to static members\b0 .\par
\par
\par
PASSED BY VALUE\par
- \b Primitives \b0 are always passed by value\par
\-- \b Object "references"\b0  are passed by value. So it looks like the object is passed by reference but actually it is the value of the reference that is passed\par
\par
THIS\par
... can only be called in a constructor and that too as a first statement.\par
\par
\par
VARIABLES -------\par
-- LOCAL\par
- You cannot specify visibilty of local variables\par
\par
-- BOOLEAN\par
Boolean class has two constructors \par
  - \b Boolean(String): \cf2\b0 true if string argument ist not null \par
 \tab and equal ignC to the strin "true\cf0 "\par
  - \b Boolean(boolean\b0 ): false\par
  \tab\cf2 new Boolean("True") produces a Boolean object that represents true.\par
\tab new Boolean("yes") produces a Boolean object that represents false.\cf0\par
  - When you use the \b equality operator ( == ) with booleans\b0 , \line if exactly one of the operands is a Boolean wrapper, it is first unboxed into a boolean primitive and then the two are compared (JLS 15.21.2). \line If both are Boolean wrappers, then their references are compared just like in the case of other objects. Thus, new Boolean("true") == new Boolean("true") is false, but new Boolean("true") == Boolean.parseBoolean("true") is true.\par
\par
\par
CONVERSION Primitives\par
- A \b narrowing primitive conversion \b0 may be used if all of the following conditions are satisfied:\par
1. The expression is a compile time constant expression of type byte, char, short, or int.\par
2. The type of the variable is byte, short, or char.\par
3. The value of the expression (which is known at compile time, because it is a constant expression) is representable in the type of the variable.\par
4.  if you have a\b  final variable \b0 and \b its value fits into a smaller type\b0 , then you can assign it \b without a cast \b0 because compiler already knows its value and realizes that it can fit into the smaller type. This is called \b implicit narrowing \b0 and is\b  allowed between byte, int, char, and, short \b0 but not for long, float, and double\par
\par
- Conversion form int to float needs a cast.\par
\par
OPERATORS\par
valid one's\par
- instanceOf\par
hinweise:\par
- postinkrement k++;  nur bei direkter Zuweisung nachrangig ausgef\'fchrt, \par
bsp:       for ( int i = 0; i <= 3; i++)\{ k++; sout: k \} <> l = k++; //hier inkr n. Zuw\par
\par
\par
PRECEDENCE\line - . operator has more precedence than the cast operator \par
   Bsp:  int k = ((Integer) t).intValue()/9 (works); <>\par
\tab    int k = (Integer) t.intValue()/9 (fails); \par
\par
\par
FLOW ------------\par
\par
-- SWITCH\par
  switch Compile-Time Konstante:\par
Deklarierung und Zuweisung in Einem.\par
- Only String, byte, char, short, int, (and their wrapper classes Byte, Character, Short, and Integer), and enums\par
- An empty switch block is a valid construct\par
\par
\par
\par
STRING\par
Methods\par
- length()  // is final\par
- charAt()\par
- indexOf()\par
- substring()\par
- toLowerCase()\par
- toUpperCase()\par
- equals() / equalsIgnoreCase()\par
\pard\f1\fs19 method checks whether two \f2\fs18 String \f1\fs19 objects contain exactly the same characters\par
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803 in the same order.\f0\fs24\par
- startsWith() / endWith()\par
- contains()\par
- replace()\par
- trim()\par
- compareTo() does a lexicographical (like a dictionary) comparison. It stops at the first place where the strings have different letters.\par
If left hand side is bigger, it returns a positive number otherwise it returns a negative number. The value is equal to the difference of their unicode values.\par
If there is no difference then it returns zero. In this case,  it will return ( 'h' - 'H') which is 32\line "hello world".compareTo("Hello world")\par
\par
\par
STRINGS\par
- String is a final class and final classes cannot be extended\par
\par
Strings <> References\par
1. Literal strings within the same class in the same package represent references to the same String object.\par
 \par
2. Literal strings within different classes in the same package represent references to the same String object. \par
\par
3. Literal strings within different classes in different packages likewise represent references to the same String object. \par
\par
4. Strings computed by constant expressions are computed at compile time and then treated as if they were literals. \par
\par
5. Strings computed at run time are newly created and therefore are distinct. (So line 4 prints false.)\par
\par
6. The result of explicitly interning a computed string is the same string as any pre-existing literal string with the same contents.\par
\par
We advise you to read section 3.10.5 String Literals in Java Language Specification\par
\par
TOSTRING\par
1. When one of the operands of the + operator is a String and other is an object (other than String), toString method is called on the other operand and then both the Strings are concatenated to produce the result of the operation.\par
\par
2. Object class contains an implementation of toString that returns the name of the class (including the package name) and the hash code of the object in the format <classname>@<hashcode>. For example, System.out.println("Hello, "+new Object()); will print Hello, java.lang.Object@3cd1a2f1, where 3cd1a2f1 is the hash code of the object.\par
\par
\par
STRING BUFFER\par
   Methods\par
- append()\par
- delete()\par
- insert()\par
- replace()\par
- reverse()\par
- keine trim() -Methode\par
\par
\par
STRING BUILDER\par
  is final\par
  Methods\par
analolg zu StringBuffer\par
\par
ARRAY\par
- In Java, arrays are just like regular Objects and arrays of different types have different\b  class names\b0 . For example, the class name of an\b  int[] \b0 is\b  [I \b0 and the class name for \b int[][]\b0  is \b [[I\b0 .\par
- For array classes, the \b isArray() \b0 method of a Class \b returns true\b0 . For example, twoD.getClass().isArray() will return true.\par
\par
ARRAY LIST\par
  Methods\par
- add()\par
- remove()\par
- set()\par
- isEmpty()\par
- size()\par
- clear()\par
- contains()\par
- equals()\par
\pard\f2\fs18 ArrayList \f1\fs19 has a custom implementation of \f2\fs18 equals() \f1\fs19 so you can compare two lists\par
to see if they \b contain the same elements in the same order\b0 .\par
\f2\fs18 boolean equals(Object object) s134\par
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\f0\fs24  Sorting\par
- Collection.sort(numbers);\par
\par
LIST\par
\par
LIST\tab <> ARRAYLIST\par
List is an Interface. Arraylist is a class.\par
List is Generic. Arraylist is Specific.\par
The two can be substituted, but it is not recommended. This is the most recommended syntax:\par
List list = new ArrayList();\par
\par
\par
EQUALS\par
- String (Pool)\par
- String (Object)\par
- ArrayList\par
\par
CONVERTING array and List\par
ArrayList -> array\par
\pard\f2\fs18 3: \b List<String> list = new ArrayList<>()\b0 ; //Liste erzeugen\par
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803 4: list.add("hawk");\par
\pard 5: list.add("robin");\par
\par
\b 8: String[] stringArray = list.toArray(new String[0]);\b0\par
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803 9: System.out.println(stringArray.length); // 2\f0\fs24\par
\par
Array -> LIst\par
\pard\f2\fs18 20: String[] array = \{ "hawk", "robin" \}; // [hawk, robin]\par
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803 21: \b List<String> list = Arrays.asList(array\b0 ); // returns fixed size list\f0\fs24\par
\par
SORTING\par
\par
\par
ACCESS MODIFIERS\par
Class -> protected in superclass\par
- Class inherits from superclass\par
    ClassMethod\par
-- without reference (directly) \par
\tab -> package access to superclass members\par
    ClassMethod + new Object \par
-- with Class Reference\par
\tab  -> package access to superclass members\par
-- with superclass Reference\par
\tab  -> no package access to superclass members //No Compiles\par
\par
HIDING\line - A final variable can be hidden in a subclass\par
\par
CLASS\par
- The visibility of the class is not limited by the visibility of its members. \par
A class with all the members declared private can still be declared public or a class having all public members may be declared private.\par
\par
CONSTRUCTOR\par
- It is provided by the compiler only if the class does not define any constructo\par
- It calls the no-args constructor of the super class.\par
- If a subclass does not have any declared constructors, the implicit default constructor of the subclass will have a call to \b super( ).\b0\par
\par
MAIN\par
- zeroth element of the string array contains: "java"\par
Most of the actual date related classes in the Date-Time API such as LocalDate, LocalTime, and LocalDateTime are immutable.\par
- you can create arrays of any type with length zero\par
\par
IMPORT\par
- need to use the class's fully qualified name \par
   \cf2 exp: util.log4j.Logger logger = new util.log4j.Logger();\cf0\par
\par
INTERFACES\par
- All Variables (member vars) are public static final\par
\par
\par
ABSTRACT CLASS\par
- A subclass can be declared abstract regardless of whether the superclass was declared abstract. \par
- A class cannot be declared abstract and final at the same time. This restriction makes sense because abstract classes need to be subclassed to be useful and final forbids subclasses.\par
\par
INHERITANCE\par
- \b Covariant \b0 returns: .. an overriding method can chante the returnt type of a subclass of the return type declared in the overriden method. ( not for primitives)  enthu 1/21\par
\par
ASSIGNMENT\par
A subclass can ALWAYS be assigned to a super class variable without any cast\par
\par
INSTANCE\par
\par
\par
\par
STATIC\line -- STATIC METHOD\line   - To call a static method of another class, you must use the name of the other class, for example OtherClass.staticMethod();\line\line\line\par
\par
LOCALDATE, LOCALTIME, LOCALDATETIME\par
- implement TemporalAccessor.\par
- DateTime API uses calendar system defined in ISO-8601\par
- Most of the actual date related classes in the Date-Time API such as LocalDate, LocalTime, and LocalDateTime are\b  immutable\b0 .\par
\par
DATE\par
Represent just a date without any time or zone information\par
- java.util \par
\par
LAMBDAs\par
- PREDICATE\par
  - has only one abstract method (among other non-abstract methods) \par
  - signature: public boolean test(T,t);\par
  -\b  Predicate is typed to List \b0 (not ArrayList) in the checkList method, therefore, the parameter type in the lambda expression must also be List. It cannot be ArrayList.\par
\par
GARBAGE COLLECTION\par
1. An object can be made eligible for garbage collection by making sure there are no references pointing to that object.\par
\par
2. You cannot directly invoke the garbage collector. You can suggest the JVM to perform garbage collection by calling System.gc();\par
\par
}
 